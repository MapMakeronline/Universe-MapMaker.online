# Backend Integration Guide

## üéØ Nowa Architektura (RTK Query Only)

Od teraz **CA≈ÅA komunikacja z backendem** odbywa siƒô przez **jeden `baseApi`** (RTK Query). Koniec z duplikacjƒÖ fetch/axios!

## üìÅ Struktura Katalog√≥w

```
src/backend/
‚îú‚îÄ‚îÄ client/
‚îÇ   ‚îî‚îÄ‚îÄ base-api.ts           # ‚úÖ JEDYNE ≈∫r√≥d≈Ço komunikacji z backendem
‚îÇ
‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îú‚îÄ‚îÄ auth.api.ts           # RTK Query endpoints dla auth
‚îÇ   ‚îî‚îÄ‚îÄ index.ts              # Eksport publiczny
‚îÇ
‚îú‚îÄ‚îÄ projects/
‚îÇ   ‚îú‚îÄ‚îÄ projects.api.ts       # RTK Query endpoints dla projekt√≥w
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ
‚îú‚îÄ‚îÄ layers/
‚îÇ   ‚îú‚îÄ‚îÄ layers.api.ts         # RTK Query endpoints dla warstw
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ
‚îú‚îÄ‚îÄ users/
‚îÇ   ‚îú‚îÄ‚îÄ users.api.ts          # RTK Query endpoints dla u≈ºytkownik√≥w
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ
‚îú‚îÄ‚îÄ types.ts                  # Wszystkie typy TypeScript
‚îî‚îÄ‚îÄ index.ts                  # Eksport publiczny (ca≈Çy backend)
```

## üîë Kluczowa Zasada: Jeden baseApi

**ZAWSZE** u≈ºywaj `baseApi.injectEndpoints()` zamiast `createApi()`:

### ‚ùå Z≈ÅE (stary spos√≥b):
```typescript
// ‚ùå NIE R√ìB TEGO - tworzy nowƒÖ instancjƒô API!
export const projectsApi = createApi({
  reducerPath: 'projectsApi',
  baseQuery: fetchBaseQuery({ baseUrl: '...' }),
  endpoints: (builder) => ({ ... }),
});
```

### ‚úÖ DOBRE (nowy spos√≥b):
```typescript
// ‚úÖ ROBIMY TAK - rozszerza baseApi!
import { baseApi } from '../client/base-api';

export const projectsApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    getProjects: builder.query<ProjectsResponse, void>({
      query: () => '/dashboard/projects/',
      providesTags: ['Projects'],
    }),
  }),
});
```

## üöÄ Jak U≈ºywaƒá w Komponentach

### Przyk≈Çad 1: Login (Auth Module)

```typescript
// src/components/auth/LoginForm.tsx
import { useLoginMutation } from '@/backend';

export function LoginForm() {
  const [login, { isLoading, error }] = useLoginMutation();

  const handleSubmit = async (credentials: { username: string; password: string }) => {
    try {
      const result = await login(credentials).unwrap();
      console.log('Logged in:', result.user);
      // Token automatically saved to localStorage by auth.api.ts
    } catch (err) {
      console.error('Login failed:', err);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
    </form>
  );
}
```

### Przyk≈Çad 2: Projects (Projects Module)

```typescript
// src/components/dashboard/OwnProjects.tsx
import { useGetProjectsQuery, useCreateProjectMutation, useDeleteProjectMutation } from '@/backend';

export function OwnProjects() {
  // Fetch projects
  const { data, isLoading, error, refetch } = useGetProjectsQuery();

  // Create project
  const [createProject] = useCreateProjectMutation();

  // Delete project
  const [deleteProject] = useDeleteProjectMutation();

  const handleCreate = async () => {
    const result = await createProject({
      project: 'MyNewProject',
      projectDescription: 'Test project',
    }).unwrap();

    console.log('Created project:', result.data.db_name); // Real project_name with suffix
  };

  const handleDelete = async (projectName: string) => {
    await deleteProject({ project: projectName });
    // Cache automatically invalidated - list refreshes!
  };

  return (
    <div>
      {data?.list_of_projects.map(project => (
        <div key={project.project_name}>
          {project.custom_project_name}
          <button onClick={() => handleDelete(project.project_name)}>Delete</button>
        </div>
      ))}
    </div>
  );
}
```

### Przyk≈Çad 3: Layers (Layers Module)

```typescript
// src/components/map/AddLayerButton.tsx
import { useAddGeoJsonLayerMutation } from '@/backend';

export function AddLayerButton() {
  const [addLayer, { isLoading }] = useAddGeoJsonLayerMutation();

  const handleAddLayer = async (file: File) => {
    await addLayer({
      project_name: 'MyProject_1',
      layer_name: 'NewLayer',
      geojson: file,
      epsg: 'EPSG:4326',
    }).unwrap();

    // Automatically invalidates 'QGIS' and 'Layers' tags
    // Tree.json refetches automatically!
  };

  return <button onClick={handleAddLayer}>Add Layer</button>;
}
```

### Przyk≈Çad 4: User Profile (Users Module)

```typescript
// src/components/dashboard/UserSettings.tsx
import { useGetUserProfileQuery, useUpdateProfileMutation } from '@/backend';

export function UserSettings() {
  const { data: user } = useGetUserProfileQuery();
  const [updateProfile] = useUpdateProfileMutation();

  const handleUpdate = async () => {
    await updateProfile({
      first_name: 'Jan',
      last_name: 'Kowalski',
      company_name: 'Firma XYZ',
    }).unwrap();

    // User data automatically saved to localStorage
  };

  return <div>{user?.email}</div>;
}
```

## üè∑Ô∏è Cache Invalidation (Tag System)

RTK Query automatycznie od≈õwie≈ºa dane gdy zmienia siƒô stan. U≈ºywamy **tag√≥w**:

### Dostƒôpne Tagi:
- `Auth` - Login, register, current user
- `Projects` - Lista projekt√≥w u≈ºytkownika
- `PublicProjects` - Lista projekt√≥w publicznych
- `Layers` - Warstwy projektu
- `QGIS` - tree.json, layer order
- `Users` - Profil u≈ºytkownika

### Przyk≈Çad: Toggle Publish

```typescript
togglePublish: builder.mutation<
  { message: string },
  { project: string; publish: boolean }
>({
  query: ({ project, publish }) => ({
    url: '/api/projects/publish',
    method: 'POST',
    body: { project, publish },
  }),
  // Invalidate multiple tags
  invalidatesTags: (result, error, arg) => [
    { type: 'Project', id: arg.project },
    { type: 'Projects', id: 'LIST' },
    { type: 'PublicProjects', id: 'LIST' }, // Public list also refreshes!
  ],
}),
```

Gdy wywo≈Çasz `togglePublish()`, RTK Query automatycznie:
1. Wysy≈Ça ≈ºƒÖdanie POST
2. Invaliduje tagi
3. Od≈õwie≈ºa `useGetProjectsQuery()` i `useGetPublicProjectsQuery()`

## ‚ö° Optimistic Updates

Mo≈ºesz zaktualizowaƒá UI **przed** odpowiedziƒÖ z serwera:

```typescript
togglePublish: builder.mutation({
  async onQueryStarted({ project, publish }, { dispatch, queryFulfilled }) {
    // 1. Optimistic update (instant UI change)
    const patchResult = dispatch(
      projectsApi.util.updateQueryData('getProjects', undefined, (draft) => {
        const foundProject = draft.list_of_projects.find(p => p.project_name === project);
        if (foundProject) {
          foundProject.published = publish; // Change immediately!
        }
      })
    );

    try {
      // 2. Wait for server response
      await queryFulfilled;
    } catch {
      // 3. Rollback on error
      patchResult.undo();
    }
  },
}),
```

## üîç Polling (Auto-refresh)

Automatyczne od≈õwie≈ºanie co X sekund:

```typescript
const { data } = useGetProjectsQuery(undefined, {
  pollingInterval: 30000, // 30 seconds
  refetchOnFocus: true,   // Refresh when user returns to tab
  refetchOnMountOrArgChange: true, // Refresh on mount
});
```

## üì¶ Jak Dodaƒá Nowy Endpoint

### Krok 1: Dodaj endpoint do modu≈Çu

```typescript
// src/backend/projects/projects.api.ts
export const projectsApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    // ... existing endpoints ...

    // NEW ENDPOINT
    updateProjectSettings: builder.mutation<
      { message: string },
      { project: string; settings: Record<string, any> }
    >({
      query: ({ project, settings }) => ({
        url: '/api/projects/settings',
        method: 'POST',
        body: { project, ...settings },
      }),
      invalidatesTags: (result, error, arg) => [
        { type: 'Project', id: arg.project },
      ],
    }),
  }),
});

// Export the hook
export const {
  // ... existing hooks ...
  useUpdateProjectSettingsMutation, // NEW HOOK
} = projectsApi;
```

### Krok 2: U≈ºyj w komponencie

```typescript
import { useUpdateProjectSettingsMutation } from '@/backend';

const [updateSettings] = useUpdateProjectSettingsMutation();
await updateSettings({ project: 'MyProject_1', settings: { basemap: 'satellite' } });
```

## üîÑ Migracja ze Starego API

### Przed (fetch/axios):
```typescript
// ‚ùå OLD: Manual fetch
const response = await fetch('https://api.universemapmaker.online/dashboard/projects/', {
  headers: {
    'Authorization': `Token ${localStorage.getItem('authToken')}`,
  },
});
const data = await response.json();
```

### Po (RTK Query):
```typescript
// ‚úÖ NEW: RTK Query hook
const { data, isLoading, error } = useGetProjectsQuery();
// Token automatically added from baseApi!
// Caching, invalidation, polling - all automatic!
```

## üìä Redux DevTools

RTK Query integruje siƒô z Redux DevTools:

1. Otw√≥rz Redux DevTools w przeglƒÖdarce
2. Zak≈Çadka "State" ‚Üí `api` ‚Üí `queries`
3. Widzisz wszystkie zapytania, cache, status
4. Zak≈Çadka "Actions" ‚Üí widzisz wszystkie API calls

## üß™ Testing

### Test 1: Login Flow
```bash
# Open browser console
1. Go to /login
2. Enter credentials
3. Check console: "üî¥ API Error" or success
4. Check localStorage: authToken should be saved
```

### Test 2: Projects CRUD
```bash
1. Go to /dashboard
2. Create project ‚Üí check console for db_name
3. Delete project ‚Üí list should refresh automatically
4. Toggle publish ‚Üí should see optimistic update (instant)
```

### Test 3: Layer Operations
```bash
1. Open map (/map?project=test)
2. Add GeoJSON layer ‚Üí tree.json should refresh
3. Toggle layer visibility ‚Üí layer disappears/appears
4. Check Redux DevTools ‚Üí see cache invalidation
```

## üéì Najlepsze Praktyki

### 1. Zawsze u≈ºywaj hook√≥w z `@/backend`
```typescript
// ‚úÖ GOOD
import { useGetProjectsQuery } from '@/backend';

// ‚ùå BAD
import { useGetProjectsQuery } from '@/redux/api/projectsApi';
```

### 2. U≈ºywaj `.unwrap()` dla error handling
```typescript
try {
  const result = await createProject(data).unwrap();
  // Success handling
} catch (err) {
  // Error handling
}
```

### 3. Nie duplikuj fetch√≥w
```typescript
// ‚ùå BAD - manual fetch
const response = await fetch('/api/projects/...');

// ‚úÖ GOOD - RTK Query hook
const { data } = useGetProjectsQuery();
```

### 4. Wykorzystaj cache
```typescript
// RTK Query automatically caches!
// Multiple components can call useGetProjectsQuery()
// Only 1 request is made, others use cache!

function Component1() {
  const { data } = useGetProjectsQuery(); // Request 1
}

function Component2() {
  const { data } = useGetProjectsQuery(); // Uses cache from Component1!
}
```

## üîó Przydatne Linki

- [RTK Query Docs](https://redux-toolkit.js.org/rtk-query/overview)
- [Cache Invalidation](https://redux-toolkit.js.org/rtk-query/usage/automated-refetching)
- [Optimistic Updates](https://redux-toolkit.js.org/rtk-query/usage/optimistic-updates)

## üìù TODO: Phase 2 Migration

Po przetestowaniu nowej struktury:

1. ‚úÖ Usu≈Ñ stare `src/api/` (fetch-based endpoints) - NIEU≈ªYWANE
2. ‚è≥ Zmigruj `layersApi` do `baseApi.injectEndpoints()` (obecnie re-export)
3. ‚è≥ Zmigruj `stylesApi` i `adminApi` do `baseApi.injectEndpoints()`
4. ‚è≥ Usu≈Ñ stare `src/redux/api/` po pe≈Çnej migracji
5. ‚è≥ Zaktualizuj wszystkie komponenty do `@/backend` imports

---

## üéâ Gotowe!

Masz teraz **jednƒÖ, sp√≥jnƒÖ architekturƒô backendu** opartƒÖ na RTK Query. Wszystkie modu≈Çy (auth, projects, layers, users) dzia≈ÇajƒÖ przez jeden `baseApi`.

**Pytania?** Sprawd≈∫ `src/backend/` i dokumentacjƒô RTK Query!
